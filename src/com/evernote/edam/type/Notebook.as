/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.evernote.edam.type {
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.Set;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;
import org.syncon.evernote.utils.Convert64BitNumberToNumber;

  /**
   * A unique container for a set of notes.
   * <dl>
   * <dt>guid</dt>
   *   <dd>The unique identifier of this notebook.
   *   <br/>
   *   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
   *   <br/>
   *   Regex:  EDAM_GUID_REGEX
   *   </dd>
   * 
   * <dt>name</dt>
   *   <dd>A sequence of characters representing the name of the
   *   notebook.  May be changed by clients, but the account may not contain two
   *   notebooks with names that are equal via a case-insensitive comparison.
   *   Can't begin or end with a space.
   *   <br/>
   *   Length:  EDAM_NOTEBOOK_NAME_LEN_MIN - EDAM_NOTEBOOK_NAME_LEN_MAX
   *   <br/>
   *   Regex:  EDAM_NOTEBOOK_NAME_REGEX
   *   </dd>
   * 
   * <dt>updateSequenceNum</dt>
   *   <dd>A number identifying the last transaction to
   *   modify the state of this object.  The USN values are sequential within an
   *   account, and can be used to compare the order of modifications within the
   *   service.
   *   </dd>
   * 
   * <dt>defaultNotebook</dt>
   *   <dd>If true, this notebook should be used for new notes
   *   whenever the user has not (or cannot) specify a desired target notebook.
   *   For example, if a note is submitted via SMTP email.
   *   The service will maintain at most one defaultNotebook per account.
   *   If a second notebook is created or updated with defaultNotebook set to
   *   true, the service will automatically update the prior notebook's
   *   defaultNotebook field to false.  If the default notebook is deleted
   *   (i.e. "active" set to false), the "defaultNotebook" field will be
   *   set to false by the service.  If the account has no default notebook
   *   set, the service will use the most recent notebook as the default.
   *   </dd>
   * 
   * <dt>serviceCreated</dt>
   *   <dd>The time when this notebook was created on the
   *   service. This will be set on the service during creation, and the service
   *   will provide this value when it returns a Notebook to a client.
   *   The service will ignore this value if it is sent by clients.
   *   </dd>
   * 
   * <dt>serviceUpdated</dt>
   *   <dd>The time when this notebook was last modified on the
   *   service.  This will be set on the service during creation, and the service
   *   will provide this value when it returns a Notebook to a client.
   *   The service will ignore this value if it is sent by clients.
   *   </dd>
   * 
   * <dt>publishing</dt>
   *   <dd>If the Notebook has been opened for public access (i.e.
   *   if 'published' is set to true), then this will point to the set of
   *   publishing information for the Notebook (URI, description, etc.).  A
   *   Notebook cannot be published without providing this information, but it
   *   will persist for later use if publishing is ever disabled on the Notebook.
   *   Clients that do not wish to change the publishing behavior of a Notebook
   *   should not set this value when calling NoteStore.updateNotebook().
   *   </dd>
   * 
   * <dt>published</dt>
   *   <dd>If this is set to true, then the Notebook will be
   *   accessible to the public via the 'publishing' specification, which must
   *   also be set.  If this is set to false, the Notebook will not be available
   *   to the public.
   *   Clients that do not wish to change the publishing behavior of a Notebook
   *   should not set this value when calling NoteStore.updateNotebook().
   *   </dd>
   * </dl>
   */
  public class Notebook implements TBase   {
    private static const STRUCT_DESC:TStruct = new TStruct("Notebook");
    private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 1);
    private static const NAME_FIELD_DESC:TField = new TField("name", TType.STRING, 2);
    private static const UPDATE_SEQUENCE_NUM_FIELD_DESC:TField = new TField("updateSequenceNum", TType.I32, 5);
    private static const DEFAULT_NOTEBOOK_FIELD_DESC:TField = new TField("defaultNotebook", TType.BOOL, 6);
    private static const SERVICE_CREATED_FIELD_DESC:TField = new TField("serviceCreated", TType.DOUBLE, 7);
    private static const SERVICE_UPDATED_FIELD_DESC:TField = new TField("serviceUpdated", TType.DOUBLE, 8);
    private static const PUBLISHING_FIELD_DESC:TField = new TField("publishing", TType.STRUCT, 10);
    private static const PUBLISHED_FIELD_DESC:TField = new TField("published", TType.BOOL, 11);

    private var _guid:String;
    public static const GUID:int = 1;
    private var _name:String;
    public static const NAME:int = 2;
    private var _updateSequenceNum:int;
    public static const UPDATESEQUENCENUM:int = 5;
    private var _defaultNotebook:Boolean;
    public static const DEFAULTNOTEBOOK:int = 6;
    private var _serviceCreated:Number;
    public static const SERVICECREATED:int = 7;
    private var _serviceUpdated:Number;
    public static const SERVICEUPDATED:int = 8;
    private var _publishing:Publishing;
    public static const PUBLISHING:int = 10;
    private var _published:Boolean;
    public static const PUBLISHED:int = 11;

    private var __isset_updateSequenceNum:Boolean = false;
    private var __isset_defaultNotebook:Boolean = false;
    private var __isset_serviceCreated:Boolean = false;
    private var __isset_serviceUpdated:Boolean = false;
    private var __isset_published:Boolean = false;

    public static const metaDataMap:Dictionary = new Dictionary();
    {
      metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.STRING));
      metaDataMap[NAME] = new FieldMetaData("name", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.STRING));
      metaDataMap[UPDATESEQUENCENUM] = new FieldMetaData("updateSequenceNum", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.I32));
      metaDataMap[DEFAULTNOTEBOOK] = new FieldMetaData("defaultNotebook", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.BOOL));
      metaDataMap[SERVICECREATED] = new FieldMetaData("serviceCreated", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.DOUBLE));
      metaDataMap[SERVICEUPDATED] = new FieldMetaData("serviceUpdated", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.DOUBLE));
      metaDataMap[PUBLISHING] = new FieldMetaData("publishing", TFieldRequirementType.OPTIONAL, 
          new StructMetaData(TType.STRUCT, Publishing));
      metaDataMap[PUBLISHED] = new FieldMetaData("published", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.BOOL));
    }
    {
      FieldMetaData.addStructMetaDataMap(Notebook, metaDataMap);
    }

    public function Notebook() {
    }

    public function get guid():String {
      return this._guid;
    }

    public function set guid(guid:String):void {
      this._guid = guid;
    }

    public function unsetGuid():void {
      this.guid = null;
    }

    // Returns true if field guid is set (has been asigned a value) and false otherwise
    public function isSetGuid():Boolean {
      return this.guid != null;
    }

    public function get name():String {
      return this._name;
    }

    public function set name(name:String):void {
      this._name = name;
    }

    public function unsetName():void {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public function isSetName():Boolean {
      return this.name != null;
    }

    public function get updateSequenceNum():int {
      return this._updateSequenceNum;
    }

    public function set updateSequenceNum(updateSequenceNum:int):void {
      this._updateSequenceNum = updateSequenceNum;
      this.__isset_updateSequenceNum = true;
    }

    public function unsetUpdateSequenceNum():void {
      this.__isset_updateSequenceNum = false;
    }

    // Returns true if field updateSequenceNum is set (has been asigned a value) and false otherwise
    public function isSetUpdateSequenceNum():Boolean {
      return this.__isset_updateSequenceNum;
    }

    public function get defaultNotebook():Boolean {
      return this._defaultNotebook;
    }

    public function set defaultNotebook(defaultNotebook:Boolean):void {
      this._defaultNotebook = defaultNotebook;
      this.__isset_defaultNotebook = true;
    }

    public function unsetDefaultNotebook():void {
      this.__isset_defaultNotebook = false;
    }

    // Returns true if field defaultNotebook is set (has been asigned a value) and false otherwise
    public function isSetDefaultNotebook():Boolean {
      return this.__isset_defaultNotebook;
    }

    public function get serviceCreated():Number {
      return this._serviceCreated;
    }

    public function set serviceCreated(serviceCreated:Number):void {
      this._serviceCreated = serviceCreated;
      this.__isset_serviceCreated = true;
    }

    public function unsetServiceCreated():void {
      this.__isset_serviceCreated = false;
    }

    // Returns true if field serviceCreated is set (has been asigned a value) and false otherwise
    public function isSetServiceCreated():Boolean {
      return this.__isset_serviceCreated;
    }

    public function get serviceUpdated():Number {
      return this._serviceUpdated;
    }

    public function set serviceUpdated(serviceUpdated:Number):void {
      this._serviceUpdated = serviceUpdated;
      this.__isset_serviceUpdated = true;
    }

    public function unsetServiceUpdated():void {
      this.__isset_serviceUpdated = false;
    }

    // Returns true if field serviceUpdated is set (has been asigned a value) and false otherwise
    public function isSetServiceUpdated():Boolean {
      return this.__isset_serviceUpdated;
    }

    public function get publishing():Publishing {
      return this._publishing;
    }

    public function set publishing(publishing:Publishing):void {
      this._publishing = publishing;
    }

    public function unsetPublishing():void {
      this.publishing = null;
    }

    // Returns true if field publishing is set (has been asigned a value) and false otherwise
    public function isSetPublishing():Boolean {
      return this.publishing != null;
    }

    public function get published():Boolean {
      return this._published;
    }

    public function set published(published:Boolean):void {
      this._published = published;
      this.__isset_published = true;
    }

    public function unsetPublished():void {
      this.__isset_published = false;
    }

    // Returns true if field published is set (has been asigned a value) and false otherwise
    public function isSetPublished():Boolean {
      return this.__isset_published;
    }

    public function setFieldValue(fieldID:int, value:*):void {
      switch (fieldID) {
      case GUID:
        if (value == null) {
          unsetGuid();
        } else {
          this.guid = value;
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          this.name = value;
        }
        break;

      case UPDATESEQUENCENUM:
        if (value == null) {
          unsetUpdateSequenceNum();
        } else {
          this.updateSequenceNum = value;
        }
        break;

      case DEFAULTNOTEBOOK:
        if (value == null) {
          unsetDefaultNotebook();
        } else {
          this.defaultNotebook = value;
        }
        break;

      case SERVICECREATED:
        if (value == null) {
          unsetServiceCreated();
        } else {
          this.serviceCreated = value;
        }
        break;

      case SERVICEUPDATED:
        if (value == null) {
          unsetServiceUpdated();
        } else {
          this.serviceUpdated = value;
        }
        break;

      case PUBLISHING:
        if (value == null) {
          unsetPublishing();
        } else {
          this.publishing = value;
        }
        break;

      case PUBLISHED:
        if (value == null) {
          unsetPublished();
        } else {
          this.published = value;
        }
        break;

      default:
        throw new ArgumentError("Field " + fieldID + " doesn't exist!");
      }
    }

    public function getFieldValue(fieldID:int):* {
      switch (fieldID) {
      case GUID:
        return this.guid;
      case NAME:
        return this.name;
      case UPDATESEQUENCENUM:
        return this.updateSequenceNum;
      case DEFAULTNOTEBOOK:
        return this.defaultNotebook;
      case SERVICECREATED:
        return this.serviceCreated;
      case SERVICEUPDATED:
        return this.serviceUpdated;
      case PUBLISHING:
        return this.publishing;
      case PUBLISHED:
        return this.published;
      default:
        throw new ArgumentError("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public function isSet(fieldID:int):Boolean {
      switch (fieldID) {
      case GUID:
        return isSetGuid();
      case NAME:
        return isSetName();
      case UPDATESEQUENCENUM:
        return isSetUpdateSequenceNum();
      case DEFAULTNOTEBOOK:
        return isSetDefaultNotebook();
      case SERVICECREATED:
        return isSetServiceCreated();
      case SERVICEUPDATED:
        return isSetServiceUpdated();
      case PUBLISHING:
        return isSetPublishing();
      case PUBLISHED:
        return isSetPublished();
      default:
        throw new ArgumentError("Field " + fieldID + " doesn't exist!");
      }
    }

    public function read(iprot:TProtocol):void {
      var field:TField;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case GUID:
            if (field.type == TType.STRING) {
              this.guid = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UPDATESEQUENCENUM:
            if (field.type == TType.I32) {
              this.updateSequenceNum = iprot.readI32();
              this.__isset_updateSequenceNum = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case DEFAULTNOTEBOOK:
            if (field.type == TType.BOOL) {
              this.defaultNotebook = iprot.readBool();
              this.__isset_defaultNotebook = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SERVICECREATED:
            if (field.type == TType.I64 || field.type == TType.DOUBLE) {
              this.serviceCreated = iprot.readDouble();
			  trace(  this.serviceCreated   )
              this.__isset_serviceCreated = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SERVICEUPDATED:
            if (field.type == TType.I64 || field.type == TType.DOUBLE) {
              /*
			  this.serviceUpdated = iprot.readDouble();
			  trace(  this.serviceUpdated   )
              this.__isset_serviceUpdated = true;
			  */
				var o : Object = iprot.readI64()
				var ee :  Convert64BitNumberToNumber = new Convert64BitNumberToNumber
				this.serviceUpdated = ee.input2Ints( o ) 
				this.__isset_serviceUpdated = true;
				//	trace(o)
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case PUBLISHING:
            if (field.type == TType.STRUCT) {
              this.publishing = new Publishing();
              this.publishing.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case PUBLISHED:
            if (field.type == TType.BOOL) {
              this.published = iprot.readBool();
              this.__isset_published = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public function write(oprot:TProtocol):void {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.guid != null) {
        oprot.writeFieldBegin(GUID_FIELD_DESC);
        oprot.writeString(this.guid);
        oprot.writeFieldEnd();
      }
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(UPDATE_SEQUENCE_NUM_FIELD_DESC);
      oprot.writeI32(this.updateSequenceNum);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(DEFAULT_NOTEBOOK_FIELD_DESC);
      oprot.writeBool(this.defaultNotebook);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(SERVICE_CREATED_FIELD_DESC);
      oprot.writeDouble(this.serviceCreated);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(SERVICE_UPDATED_FIELD_DESC);
      oprot.writeDouble(this.serviceUpdated);
      oprot.writeFieldEnd();
      if (this.publishing != null) {
        oprot.writeFieldBegin(PUBLISHING_FIELD_DESC);
        this.publishing.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(PUBLISHED_FIELD_DESC);
      oprot.writeBool(this.published);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    public function toString():String {
      var ret:String = new String("Notebook(");
      var first:Boolean = true;

      if (isSetGuid()) {
        ret += "guid:";
        if (this.guid == null) {
          ret += "null";
        } else {
          ret += this.guid;
        }
        first = false;
      }
      if (isSetName()) {
        if (!first) ret +=  ", ";
        ret += "name:";
        if (this.name == null) {
          ret += "null";
        } else {
          ret += this.name;
        }
        first = false;
      }
      if (isSetUpdateSequenceNum()) {
        if (!first) ret +=  ", ";
        ret += "updateSequenceNum:";
        ret += this.updateSequenceNum;
        first = false;
      }
      if (isSetDefaultNotebook()) {
        if (!first) ret +=  ", ";
        ret += "defaultNotebook:";
        ret += this.defaultNotebook;
        first = false;
      }
      if (isSetServiceCreated()) {
        if (!first) ret +=  ", ";
        ret += "serviceCreated:";
        ret += this.serviceCreated;
        first = false;
      }
      if (isSetServiceUpdated()) {
        if (!first) ret +=  ", ";
        ret += "serviceUpdated:";
        ret += this.serviceUpdated;
        first = false;
      }
      if (isSetPublishing()) {
        if (!first) ret +=  ", ";
        ret += "publishing:";
        if (this.publishing == null) {
          ret += "null";
        } else {
          ret += this.publishing;
        }
        first = false;
      }
      if (isSetPublished()) {
        if (!first) ret +=  ", ";
        ret += "published:";
        ret += this.published;
        first = false;
      }
      ret += ")";
      return ret;
    }

    public function validate():void {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
